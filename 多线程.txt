一.多线程：
	1.什么是多线程：
	 程序运行时一个进程中并发的多个线程，每个线程执行不同的任务。

	2.什么是线程：
	 线程是一个动态执行的过程，它有一个从出生到死亡的过程；细分为 新建，就绪，运行，阻塞，死亡。
		2.1 新建：
		首先使用new关键字和Tread类或者其他子类建立一个线程对象，该线程对象就处于新建状态。直到调用start()。
		2.2 就绪：
		2.3 当线程对象调用start()方法后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，等待JVM里的线程调度器调度。
		2.4 运行：
		如果就绪状态的线程获取了CPU资源，就会执行run()，此时线程就处于运行状态。处于运行状态的线程最复杂，它可以变为阻塞，就绪，死亡。
		2.5 阻塞：
		如果一个线程对象调用了sleep(),suspend()等方法，失去所占用的CPU资源后，该线程就从运行进入阻塞状态。在睡眠时间已到或者获得CPU资源以后可以重新进入就绪状态。
		 又可以分为三种：
			2.5.1 等待阻塞：运行的线程执行了wait()方法，使线程进入等待阻塞状态。
			2.5.2 同步阻塞：线程在获取synchronized同步锁失败（因为同步锁被别的线程占用）。
			2.5.3 其他阻塞：通过调用线程的sleep()或join()发出I/O请求时，线程就会进入阻塞状态。当sleep()状态超时，join()等待终止或者超时，或者I/O处理完毕，线程就会重新转入就绪状态。
		2.6 死亡：
		一个运行的状态的线程完成任务或者被其他终止条件发生时，该线程就切换到终止状态。
		
	3.创建一个线程：
		3.1 通过实现Runnable接口；run()可以重写，run()可以调用其他方法，使用其他类，并声明变量。新线程创建之后需调用它的start()方法才会运行。
		3.2 通过继承Thread类；必须重写run()方法，该方法是新线程的入口点，它也必须调用start()方法才能运行。
		3.3 通过 Callable 和 Future 创建线程：
			3.3.1 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
			3.3.2 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
			3.3.3 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
			3.3.4 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。

	4.Thread重要方法：
	 4.1 Thread对象调用的方法:
		4.1.1	public void start()
		使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
		4.1.2	public void run()
		如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。
		4.1.3	public final void setName(String name)
		改变线程名称，使之与参数 name 相同。
		4.1.4	public final void setPriority(int priority)
		 更改线程的优先级。
		4.1.5	public final void setDaemon(boolean on)
		将该线程标记为守护线程或用户线程。
		4.1.6	public final void join(long millisec)
		等待该线程终止的时间最长为 millis 毫秒。
		4.1.7	public void interrupt()
		中断线程。
		4.1.8	public final boolean isAlive()
		测试线程是否处于活动状态。
	 4.2 Thread类的静态方法:
		4.2.1	public static void yield()
		暂停当前正在执行的线程对象，并执行其他线程。
		4.2.2	public static void sleep(long millisec)
		在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。
		4.2.3	public static boolean holdsLock(Object x)
		当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。
		4.2.4	public static Thread currentThread()
		返回对当前正在执行的线程对象的引用。
		4.2.5	public static void dumpStack()
		将当前线程的堆栈跟踪打印至标准错误流。
		
	5.创建线程的三种方式的对比：
	 5.1 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。
	 5.2 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。
 

二.线程安全：
	1.什么是线程安全：
	 当多个线程访问多个类时，不管线程如何交替运行，在调用代码中不需要任何额外的同步或者协调动作，这个类都能保持正确的行为，那么这个类就是线程安全的。
	 1.1 什么是正确性：
		某个类的行为与其规范相一致。
	 
	3.原子性：
	 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B完全执行完，要么完全不执行B，那么A和B对彼此来说是原子的。
	 3.1 原子操作是指：
	  对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。
  
	4.加锁机制：
	 4.1 为什么要用到锁：
		  在线程安全的定义中来看，多个线程之间的操作无论怎么执行顺序，或者交替方式，都要保证不变性条件不被破坏。当不被不变性条件中涉及多个变量时，各个变量之间并不是相互独立的，
		  一个变量发生变化会对其他变量的值产生约束。因此一个变量发生改变，在同一个原子操作中，其他相关变量也要更新，这时候就要用到锁。
	 4.2 内置锁：
		 同步代码块（synchronized Block） 包括两个部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。
		 关键字Synchronized修饰方法就是一种同步代码块，锁就是方法调用所在的对象，静态的Synchronized方法以Class对象作为锁（
		 例如：Synchronized(xxx.class){变量，方法}，{}中就是锁住的变量和方法）。内置锁或监视锁就是以对象作为实现同步的锁。
	 4.3重入锁：
		当一个持有锁的线程再次请求进入自己持有的锁时，该请求会成功。"重入"意味着获取锁的操作的粒度是“线程”，而不是“调用”。重入的一种实现方式，为每个锁关联一个计数器和线程持有者。

		
三.线程池：
	1.什么是线程池：
	 一个可以存放重复使用的线程容器。（就如同我们平时所用的公共方法一般）
	2.为什么要使用线程池：
	 因为并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，
	 频繁创建线程和销毁线程需要时间。这时候我们就需要一种办法使得线程复用，就是线程执行完一个任务不被销毁，可以继续执行其他任务。
	3.使用的类：
	 java.uitl.concurrent.ThreadPoolExecutor
	 3.1 类中的构造器：
		corePoolSize：核心池的大小。
		maximumPoolSize：线程池最大线程数。
		keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。
		unit：参数keepAliveTime的时间单位。
		workQueue：一个阻塞队列，用来存储等待执行的任务。
		threadFactory：线程工厂，主要用来创建线程。
		handler：表示当拒绝处理任务时的策略。
		